# Snakefile for mRNA  in Eucaryotes
import os
from snakemake.utils import R

# species for which pipeline is run
SPEC = "sly"
PRJ_DIR = "../.."
GENOME_DB=PRJ_DIR+"/Scratch/SL_genome/Solanum_lycopersicum.GCA_000188115.2.28.dna.genome.fa"
TRANSCRIPTOME_DB=PRJ_DIR+"/Scratch/SL_transcriptome/Solanum_lycopersicum_Inc02193.fa"

if not os.path.exists(GENOME_DB):
     sys.exit("Pipeline configuration error: Genome database does not exist.")

if not os.path.exists(TRANSCRIPTOME_DB):
     sys.exit("Pipeline configuration error: Transcriptome database does not exist.")

# reference spikein sequences
SEQDB="/zfs/datastore0/group_root/MAD-RBAB/05_Reference-db/"
SPIKES_REF = SEQDB+"external/ERCC/ERCC92.fa"

# directory with raw reads in fastq format
FQ_DIR = PRJ_DIR+"/Scratch/raw/"
SAMPLES =  [s[:-6] for s in os.listdir(FQ_DIR) if s.endswith(".fastq")]

# spike count table directory
SCRATCH_DIR = PRJ_DIR+"/Scratch/mapped"
RESULT_DIR = PRJ_DIR+"/Results/mapping"
DIR_E = ".dexist"
PP_PACKRAT = "/zfs/datastore0/software/pipeline_packrat/WF_mapping/01"

ASSEMB_DIR = SCRATCH_DIR+"/UnmappAssemb21"
ASSEMB_HASH = 21

TMAP_PARAMS = "-M 2 -O 3 -n 16 -g 3 -a 1 -v stage1 map1 map2 map3" 

SEQ_COUNT_LOG="seq_count.txt"

rule all:
    input: (RESULT_DIR+"/{sample}_readcnt.txt".format(sample=s) for s in SAMPLES),
           (RESULT_DIR+"/{sample}_genome_cnt.txt".format(sample=s) for s in SAMPLES),
           (RESULT_DIR+"/{sample}_transc_cnt.txt".format(sample=s) for s in SAMPLES),
           (RESULT_DIR+"/{sample}_contigs_cnt.txt".format(sample=s) for s in SAMPLES),
           RESULT_DIR+"/count.png"    
    message: "Done running mRNA pipeline"

rule contig_count_table: 
       input: os.path.join(SCRATCH_DIR,"{sample}_tmap_contigs.sam")
       output: os.path.join(RESULT_DIR,"{sample}_contigs_cnt.txt")
       message: "Create contig count table" 
       shell: 
         """
	     awk '$2 == 0 {{ print $3 }} $2 == 16 {{print $3 "_rc"}}'  {input} | sort | uniq -c > {output} 
         """

rule tmap_contigs: 
     input: reads=SCRATCH_DIR+"/{sample}_tmap_genome_unmapped.fastq",
            db=SCRATCH_DIR+"/assembly100.fa.tmap.bwt"
     output: SCRATCH_DIR+"/{sample}_tmap_contigs.sam"
     message: "tmapping rest to contigs" 
     shell:
        """ 
        tmap mapall -r {input.reads} -f {SCRATCH_DIR}/assembly100.fa {TMAP_PARAMS} > {output}
        """

rule select_unmapped_contigs:
   input: ASSEMB_DIR+"/contigs.fa"
   output: SCRATCH_DIR+"/assembly100.fa"
   message: "Selecting contigs from assembly"
   shell: 
       """
	 awk 'BEGIN {{seq=""}} ($1 ~ /^>/) {{ if (seq  && (length(seq) > 99)) {{print name; print seq; seq="";  }} name=$0; next}} {{seq=seq $0}}' {input} > {output} 
       """

rule assemble_unmapped:
    input: SCRATCH_DIR+"/all_unmapped.fastq"
    output: ASSEMB_DIR+"/contigs.fa"
    message: "Assembling ummapped reads"
    shell: 
       """
         velveth {ASSEMB_DIR} {ASSEMB_HASH} -fastq {input} 
         velvetg {ASSEMB_DIR}
       """
    

rule combine_unmapped:
   input: (SCRATCH_DIR+"/{sample}_tmap_genome_unmapped.fastq".format(sample=s) for s in SAMPLES)
   output: SCRATCH_DIR+"/all_unmapped.fastq"
   message: "combining all unmapped reads to single fastq file"
   shell: " cat {input} > {output}"


rule read_distribution_count:
   input: raw=os.path.join(FQ_DIR,"{sample}.fastq"),
          trimmed=SCRATCH_DIR+"/{sample}_trimmed.fastq",
          nspike=SCRATCH_DIR+"/{sample}_spike_unmapped.fastq",
          ntransc=SCRATCH_DIR+"/{sample}_tmap_transc_unmapped.fastq",
          ngenome=SCRATCH_DIR+"/{sample}_tmap_genome_unmapped.fastq",
          ncontig=SCRATCH_DIR+"/{sample}_tmap_contigs_unmapped.fastq"
   output: os.path.join(RESULT_DIR,"{sample}_readcnt.txt")
   message: "Calculate number of reads per class for sample {wildcards.sample}. "
   shell: 
      """
        lcn_raw=`wc -l  {input.raw} | awk '{{print $1/4}}'` 
        lcn_trimmed=`wc -l  {input.trimmed} | awk '{{print $1/4}}'` 
        lcn_nspike=`wc -l  {input.nspike} | awk '{{print $1/4}}'` 
        lcn_ntransc=`wc -l  {input.ntransc} | awk '{{print $1/4}}'`
        lcn_ngenome=`wc -l  {input.ngenome} | awk '{{print $1/4}}'`
        lcn_ncontigs=`wc -l  {input.ncontig} | awk '{{print $1/4}}'`
        echo "sample\ttotal\ttrimmed\tspike\ttranscriptome\tgenome\tcontigs\tunmapped" > {output}
	echo -n "{wildcards.sample}\t"               >> {output}
	echo -n "$lcn_raw\t"                         >> {output}
	echo -n "$(($lcn_raw-$lcn_trimmed))\t"       >> {output}
	echo -n "$(($lcn_trimmed-$lcn_nspike))\t"    >> {output}
	echo -n "$(($lcn_nspike-$lcn_ntransc))\t"    >> {output}
	echo -n "$(($lcn_ntransc-$lcn_ngenome))\t"   >> {output}
	echo -n "$(($lcn_ngenome-$lcn_ncontigs))\t"  >> {output}
	echo -n "$lcn_ncontigs"                      >> {output}
      """

rule genome_count_table:
       input: os.path.join(SCRATCH_DIR,"{sample}_tmap_genome.sam")
       output: os.path.join(RESULT_DIR,"{sample}_genome_cnt.txt")
       message: "Create count table" 
       shell: 
         """
            awk -v "b=100000" 'substr($1,1,1) == "@" {{ next; }} $2 == 0 {{ print $3 " - " b*int($4/b) }} $2 == 16 {{ print $3 " + " b*int($4/b)  }} ' {input} | sort  -k1,2 -k3n | uniq -c > {output} 
         """
       

rule transcript_count_table: 
       input: os.path.join(SCRATCH_DIR,"{sample}_tmap_transc.sam")
       output: os.path.join(RESULT_DIR,"{sample}_transc_cnt.txt")
       message: "Create count table" 
       shell: 
         """
	     awk '$2 == 0 {{ print $3 }} $2 == 16 {{print $3 "_rc"}}'  {input} | sort | uniq -c > {output} 
         """


rule tmap_index: 
     input: "{s}"
     output:  "{s}.tmap.anno",
              "{s}.tmap.bwt",
              "{s}.tmap.pac",
              "{s}.tmap.sa"
     message: "Build an index for tmap"
     shell: " tmap index -f {input} "


rule tmap_genome: 
     input: SCRATCH_DIR+"/{sample}_tmap_transc_unmapped.fastq"
     output: SCRATCH_DIR+"/{sample}_tmap_genome.sam"
     message: "tmapping rest to genome" 
     shell:
        """ 
        tmap mapall -r {input} -f {GENOME_DB} {TMAP_PARAMS} > {output}
        """

rule tmap_transcriptome: 
     input: fq=SCRATCH_DIR+"/{sample}_spike_unmapped.fastq",
            db=TRANSCRIPTOME_DB+".tmap.bwt"
     output: SCRATCH_DIR+"/{sample}_tmap_transc.sam"
     message: "tmapping to transcriptome" 
     shell: "tmap mapall -r {input.fq} -f {TRANSCRIPTOME_DB} {TMAP_PARAMS} > {output}"

rule extract_unmapped: 
    input: SCRATCH_DIR+"/{s}.sam" 
    output: SCRATCH_DIR+"/{s}_unmapped.fastq"
    message: "Extract unmapped reads from sam to fastq"
    shell:
        """
        awk '$3=="*" {{printf("@%s\\n%s\\n+%s\\n%s\\n",$1,$10,$1,$11)}}' {input} > {output}
        """

# make spike count plots
rule spike_count_plots:
    input: totalcount=os.path.join(RESULT_DIR, "total_reads.csv"),
           spikecount=os.path.join(RESULT_DIR,"CountTable_spike.txt"),
           prlr="./packrat/lib-R",
           prl="./packrat/lib"
    output: countpng=os.path.join(RESULT_DIR,"count.png"),
            normcountpng=os.path.join(RESULT_DIR,"norm_count.png")
    run: R("""
           library(faradr);
           png(filename="{output.countpng}",width=1024,height=1024);
           plot(PlotSpikeCounts("{input.spikecount}"));
           dev.off();
           png(filename="{output.normcountpng}",width=1024,height=1024);
           plot(PlotNormalSpikeCounts("{input.spikecount}", "{input.totalcount}"));
           dev.off();
           """)

# Count the number of reads in the input fastq files. The 
# method assumes single sequence and quality lines.  
# By checking if the first character of every 4th line is 
# a @ the assumption is tested. 
# The much slower count_fq_reads function in sRNA_tools.py can 
# be used if the assumption does not hold. 

rule total_reads_count:
   input:  (FQ_DIR+"/{s}.fastq".format(s=sample) for sample in SAMPLES)
   output: os.path.join(RESULT_DIR, "total_reads.csv") 
   message: "Count number of reads in the raw samples."
   shell: 
     """  
	echo -n "" > {output} 
	for i in {FQ_DIR}/*.fastq ; do 
           SAMPLE=$(basename $i .fastq)
	   CNT=$(awk '(NR%4-1) {{next}} $1 ~ /^@/ {{sc++; next}} {{print "ERR"; exit -1}} END {{print sc}}' $i)
           echo "$SAMPLE\t$CNT" >> {output} 
	done
     """

rule sam2bam:
    input:  "{sample}.sam"
    output: bam = "{sample}_sorted.bam",
            bai = "{sample}_sorted.bam.bai",
    message: "Converting {wildcards.sample} to sorted and indexed bam"
    shell:
      """
        samtools view -bS {input} > {output.bam}
        samtools sort {output.bam} {wildcards.sample}_sorted
        samtools index {output.bam}
      """

rule spike_count:
    input: ("{sd}/{sample}_spike_sorted.bam.bai".format(sample=s,sd=SCRATCH_DIR) for s in SAMPLES)
    output: os.path.join(RESULT_DIR,"CountTable_spike.txt"),
    message: "Counting spike reads"
    shell: "python sRNA_tools.py count_spikes --basename _spike_sorted.bam --spike_type ERCC --bam-dir {SCRATCH_DIR} --count-dir {RESULT_DIR}" 
            
rule aln_spikes:
    input: os.path.join(SCRATCH_DIR,"{sample}_trimmed.fastq")
    output: os.path.join(SCRATCH_DIR,"{sample}_spike.sam")
    message: "Aligning reads to spike sequences."
    shell: 
        """
        tmap mapall -r {input} -f {SPIKES_REF} {TMAP_PARAMS} > {output}
        """


rule trim_reads:
    input: os.path.join(FQ_DIR,"{sample}.fastq")
    output: os.path.join(SCRATCH_DIR,"{sample}_trimmed.fastq")
    message: "Trimming reads to 50 nt. And remove reads < 25nt"
    shell: 
       """
            awk 'BEGIN {{tlen=50; lmin=25}} {{ln++; av[ln] =$0}} ln==4 {{if (length($0)>=lmin) {{ printf("%s\\n%s\\n%s\\n%s\\n", av[1],substr(av[2],1,tlen),av[3],substr($0,1,tlen)); }} ln=0; }}'  {input} > {output}
       """ 

########################################################################
#   link libs so packrat does not have to download and compile everything
rule link_packratlib:
    input:  os.path.join(PP_PACKRAT,"{s}")
    output: os.path.join("./packrat","{s}")
    message: "Symlinking packrat library"
    shell: "if [ -d {input} ] ; then ln -s {input} {output};  fi"

rule create_dir:
    output:  os.path.join("{s}",DIR_E)
    message: "Create directory {wildcards.s}"
    shell:   "mkdir -p {wildcards.s}; touch {output} "

